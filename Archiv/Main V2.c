#pragma config(Sensor, S4,     Colour,         sensorEV3_Color, modeEV3Color_Color)
#pragma config(Motor,  motorB,          lift,          tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorC,          gripper,       tmotorEV3_Medium, PIDControl, encoder)
#pragma config(Motor,  motorD,          turn,          tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define TURN_SPEED_FAST 10
#define TURN_SPEED_SLOW 3
#define LIFT_SPEED 60
#define GRIPPER_SPEED 50
#define TURN_RADIUS_MIN 0
#define TURN_RADIUS_MAX 900
#define LIFT_HEIGHT_MAX 0
#define GRIPPER_MAX 63
#define GRIPPER_MIN 0
#define GRIPPER_OFFSET_RIGHT 90
#define GRIPPER_OFFSET_LEFT 50
#define SCAN_HEIGHT 1200
#define GRIP_HEIGHT 1800
#define DROP_HEIGHT 1700
#define TRANSPORT_HEIGHT 0
#define CLOCKWISE 0
#define COUNTERCLOCKWISE 1
#define STOP 0

#define BLACK 1
#define BLUE 2
#define GREEN 3
#define YELLOW 4
#define RED 5
#define WHITE 6
#define BROWN 7

void initialising();
void homePosition();
void scanPosition();
void grip();
int drop(int positionDrop);
int searchCube(int direction);
void offset(int direction);
int checkColour();

int redDropped = 0;
int greenDropped = 0;
int blueDropped = 0;
int brownDropped = 0;
short currentColour = 0;

task main(){

	int positionGreen = 0;
	int positionBlue = 0;
	int positionRed = 0;
	int positionBrown = 0;
	int nCube = 0;
	int direction = 0;

	//Motorbremse aktivieren
	setMotorBrakeMode(turn, motorBrake);
	setMotorBrakeMode(lift, motorBrake);
	setMotorBrakeMode(gripper, motorBrake);

	initialising();

	waitForButtonPress();
	flushButtonMessages();
	sleep(2000);

	scanPosition();

  //Positionen der Würfel scannen
  while(getMotorEncoder(turn) <= TURN_RADIUS_MAX){

  	setMotorSpeed(turn, TURN_SPEED_FAST);
		currentColour = SensorValue[Colour];

		switch(currentColour){

			case BLUE:

				positionBlue = getMotorEncoder(turn);
				displayCenteredBigTextLine(4, "Blue: %d", positionBlue);
				break;

			case GREEN:

				positionGreen = getMotorEncoder(turn);
				displayCenteredBigTextLine(6, "Green: %d", positionGreen);
				break;

			case RED:

				positionRed = getMotorEncoder(turn);
				displayCenteredBigTextLine(8, "Red: %d", positionRed);
				break;

			case BROWN:

				positionBrown = getMotorEncoder(turn);
				displayCenteredBigTextLine(10, "Red: %d", positionRed);
				break;
		}
	}

	setMotorSpeed(turn, STOP);
	homePosition();

	waitForButtonPress();

	scanPosition();

	while(nCube < 3){

		currentColour = BLACK;
		direction = searchCube(direction);
		currentColour = SensorValue[Colour];

		switch(currentColour){

			case BLUE:

				offset(direction);
				grip();
				blueDropped = drop(positionBlue);
				nCube++;
				break;

			case GREEN:

				offset(direction);
				grip();
				greenDropped = drop(positionGreen);
				nCube++;
				break;

			case RED:

				offset(direction);
				grip();
				redDropped = drop(positionRed);
				nCube++;
				break;

			case BROWN:

				offset(direction);
				grip();
				brownDropped = drop(positionBrown);
				nCube++;
				break;

		}

		sleep(500);

  }

  homePosition();

}

//Motor drehen kalibrieren. Max Links = 0, Max Rechts = 600
void initialising(){

	setMotorTarget(turn, -(TURN_RADIUS_MAX/2), TURN_SPEED_FAST);
  waitUntilMotorStop(turn);
  resetMotorEncoder(turn);
  sleep(500);
  setMotorTarget(turn, TURN_RADIUS_MAX, TURN_SPEED_FAST);
  waitUntilMotorStop(turn);
  sleep(500);
  setMotorTarget(turn, TURN_RADIUS_MAX/2, TURN_SPEED_FAST);
  waitUntilMotorStop(turn);
}

void homePosition(){
	//Arm heben
	setMotorTarget(lift, LIFT_HEIGHT_MAX, LIFT_SPEED);
  waitUntilMotorStop(lift);

  //Arm in Mitte
  setMotorTarget(turn, (TURN_RADIUS_MAX/2), TURN_SPEED_FAST);
  waitUntilMotorStop(turn);
}

void scanPosition(){
	//Arm an linkes Ende bewegen
	setMotorTarget(turn, TURN_RADIUS_MIN, TURN_SPEED_FAST);
	waitUntilMotorStop(turn);

	//Arm auf Scanhoehe heben.
	setMotorTarget(lift, SCAN_HEIGHT, LIFT_SPEED);
  waitUntilMotorStop(lift);
}

//Greifvorgang von Scanhoehe durchfuehren. Endposition ist Transporthoehe.
void grip(){

	//Greifer oeffnen
	setMotorTarget(gripper, GRIPPER_MAX, GRIPPER_SPEED);
	waitUntilMotorStop(gripper);

	//Arm nach unten bewegen
	setMotorTarget(lift, GRIP_HEIGHT, LIFT_SPEED);
	waitUntilMotorStop(lift);

	//Greifer schliessen
	setMotorTarget(gripper, GRIPPER_MIN, GRIPPER_SPEED);
	sleep(500);

	//Arm nach oben bewegen
	setMotorTarget(lift, TRANSPORT_HEIGHT, LIFT_SPEED);
	waitUntilMotorStop(lift);
}

//Packet ablegen von Transporthoehe. Endposition Scanhoehe.
int drop(int positionDrop){

	//Arm zum Abwerfen bewegen
	setMotorTarget(turn, positionDrop, TURN_SPEED_FAST);
	waitUntilMotorStop(turn);

	//Arm senken
	setMotorTarget(lift, DROP_HEIGHT, LIFT_SPEED);
	waitUntilMotorStop(lift);

	//Greifer oeffnen
	setMotorTarget(gripper, GRIPPER_MAX, GRIPPER_SPEED);
	waitUntilMotorStop(gripper);

	//Arm heben
	setMotorTarget(lift, SCAN_HEIGHT, LIFT_SPEED);
	waitUntilMotorStop(lift);

	//Greifer schliessen
	setMotorTarget(gripper, GRIPPER_MIN, GRIPPER_SPEED);
	waitUntilMotorStop(gripper);

	return 1;

}

//Würfel suchen durch hin- und herschwenken des Roboterarms
int searchCube(int direction){

	if(direction == CLOCKWISE){

		//Solange Farbe == schwarz oder weiss ist und der maximale Schwenkradius nicht erreicht wurde: Arm im Uhrzeigersinn drehen
		while((checkColour() == 1) && (getMotorEncoder(turn) <= TURN_RADIUS_MAX)){
			setMotorSpeed(turn, TURN_SPEED_FAST);
		}
		setMotorSpeed(turn, STOP);
		return 1;
	} else {

		//Solange Farbe != rot und der maximale Schwenkradius nicht erreicht ist: Arm im Uhrzeigersinn drehen
		while((checkColour() == 1) && (getMotorEncoder(turn) >= TURN_RADIUS_MIN)){
			setMotorSpeed(turn, -TURN_SPEED_FAST);
		}
		setMotorSpeed(turn, STOP);
		return 0;
	}
}

//Ueberpruefen, ob Farbe schon abgearbeitet wurde
int checkColour(){

	int currentColour = SensorValue[Colour];
	switch(currentColour){

		case BLUE:

			if(blueDropped != 1){
				return 0;
			} else {
				return 1;
			}
			break;

		case GREEN:

			if(greenDropped != 1){
				return 0;
			} else {
				return 1;
			}
			break;

		case RED:

			if(redDropped != 1){
				return 0;
			} else {
				return 1;
			}
			break;

		case BROWN:

			if(brownDropped != 1){
				return 0;
			} else {
				return 1;
			}
			break;

	}
	return 1;
}

//Offset fahren in Abhängigkeit der Drehrichtung
void offset(int direction){

	if(direction == CLOCKWISE){

		moveMotorTarget(turn, GRIPPER_OFFSET_RIGHT, TURN_SPEED_SLOW);
		waitUntilMotorStop(turn);

	} else {

		moveMotorTarget(turn, GRIPPER_OFFSET_LEFT, TURN_SPEED_SLOW);
		waitUntilMotorStop(turn);

	}
}
