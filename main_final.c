#pragma config(Sensor, S4,     Colour,         sensorEV3_Color, modeEV3Color_Color)
#pragma config(Motor,  motorB,          lift,          tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorC,          gripper,       tmotorEV3_Medium, PIDControl, encoder)
#pragma config(Motor,  motorD,          turn,          tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//Parameter definieren
#define TURN_SPEED_FAST 10
#define TURN_SPEED_SLOW 3
#define LIFT_SPEED 60
#define GRIPPER_SPEED 50
#define TURN_RADIUS_MIN 0
#define TURN_RADIUS_MAX 900
#define LIFT_HEIGHT_MAX 0
#define GRIPPER_MAX 63
#define GRIPPER_MIN 0
#define GRIPPER_OFFSET_RIGHT 80
#define GRIPPER_OFFSET_LEFT 60
#define SCAN_HEIGHT 1200
#define GRIP_HEIGHT 1800
#define DROP_HEIGHT 1700
#define TRANSPORT_HEIGHT 0
#define CLOCKWISE 0
#define COUNTERCLOCKWISE 1
#define STOP 0

//Farben definieren
#define BLACK 1
#define BLUE 2
#define GREEN 3
#define YELLOW 4
#define RED 5
#define WHITE 6
#define BROWN 7

//Funktionsprototypen
int select();
void initialise();
void homePosition();
void scanStartPosition();
void grip();
int drop(int positionDrop);
int searchCube(int direction);
void offset(int direction);
int checkColour();

//Globale Variablen
int redDropped = 0;
int greenDropped = 0;
int blueDropped = 0;
short currentColour = 0;

task main(){

	int positionGreen = 0;
	int positionBlue = 0;
	int positionRed = 0;
	int nCube = 0;
	int direction = 0;

	//Motorbremse aktivieren
	setMotorBrakeMode(turn, motorBrake);
	setMotorBrakeMode(lift, motorBrake);
	setMotorBrakeMode(gripper, motorBrake);

	//Programmschleife
	while(1){

		//Menue fuer Initialisierung
		displayCenteredBigTextLine(4, "Start");
		displayCenteredBigTextLine(6, "initialisation?");
		displayCenteredBigTextLine(10, "> yes");
		displayCenteredBigTextLine(12, "<  no");

		if (select() == 1){
			sleep(2000);
			initialise();
		}

		//Menue zum einlesen der Wuerfelpositionen
		displayCenteredBigTextLine(4, "Press any");
		displayCenteredBigTextLine(6, "button to");
		displayCenteredBigTextLine(8, "start scanning.");

		waitForButtonPress();
		flushButtonMessages();
		eraseDisplay();

		//Positionen der Wuerfel scannen
		do{
			sleep(2000);
			scanStartPosition();

  			while(getMotorEncoder(turn) <= TURN_RADIUS_MAX){

  				setMotorSpeed(turn, TURN_SPEED_FAST);
				currentColour = SensorValue[Colour];

				switch(currentColour){

					case BLUE:

						positionBlue = getMotorEncoder(turn);
						break;

					case GREEN:

						positionGreen = getMotorEncoder(turn);
						break;

					case RED:

						positionRed = getMotorEncoder(turn);
						break;

				}
			}

			setMotorSpeed(turn, STOP);
			homePosition();

			//Positionen der Wuerfel ausgeben. Auswahl erneut scannen?
			displayCenteredBigTextLine(0, "Blue: %d", positionBlue);
			displayCenteredBigTextLine(2, "Green: %d", positionGreen);
			displayCenteredBigTextLine(4, "Red: %d", positionRed);
			displayBigTextLine(10, "< scan again");
			displayBigTextLine(12, "> start sorting");

		} while (select() == 0);

		sleep(2000);
		scanStartPosition();

		//Wuerfel finden und sortieren
		while(nCube < 3){

			currentColour = BLACK;
			direction = searchCube(direction);

			switch(currentColour){

				case BLUE:

					offset(direction);
					grip();
					blueDropped = drop(positionBlue);
					nCube++;
					break;

				case GREEN:

					offset(direction);
					grip();
					greenDropped = drop(positionGreen);
					nCube++;
					break;

				case RED:

					offset(direction);
					grip();
					redDropped = drop(positionRed);
					nCube++;
					break;

			}

			sleep(500);

  		}

  	homePosition();
  	nCube = 0;
  	blueDropped = 0;
  	greenDropped = 0;
  	redDropped = 0;

	}
}

//Auf Auswahl Taste rechts/Taste links warten und Auswahl zurueckgeben
int select(){

	while(1){
		if(getButtonPress(buttonRight) == 1){
			flushButtonMessages();
			eraseDisplay();
			return 1;
		} else if(getButtonPress(buttonLeft) == 1){
			flushButtonMessages();
			eraseDisplay();
			return 0;
		}
	}
}

//Motor drehen kalibrieren. Linksanschlag als 0 definieren.
void initialise(){

	moveMotorTarget(turn, (TURN_RADIUS_MAX/2), -TURN_SPEED_FAST);
  	waitUntilMotorStop(turn);
  	resetMotorEncoder(turn);
  	sleep(500);
  	setMotorTarget(turn, TURN_RADIUS_MAX, TURN_SPEED_FAST);
  	waitUntilMotorStop(turn);
  	sleep(500);
  	setMotorTarget(turn, TURN_RADIUS_MAX/2, TURN_SPEED_FAST);
  	waitUntilMotorStop(turn);
}

//Home Position anfahren
void homePosition(){

	//Arm heben
	setMotorTarget(lift, LIFT_HEIGHT_MAX, LIFT_SPEED);
  	waitUntilMotorStop(lift);

  	//Arm zu Mitte bewegen
  	setMotorTarget(turn, (TURN_RADIUS_MAX/2), TURN_SPEED_FAST);
  	waitUntilMotorStop(turn);
}

//Ausgangspunkt fuer Scan anfahren
void scanStartPosition(){

	//Arm an linkes Ende bewegen
	setMotorTarget(turn, TURN_RADIUS_MIN, TURN_SPEED_FAST);
	waitUntilMotorStop(turn);

	//Arm auf Scanhoehe heben.
	setMotorTarget(lift, SCAN_HEIGHT, LIFT_SPEED);
  	waitUntilMotorStop(lift);
}

//Greifvorgang von Scanhoehe durchfuehren. Endposition ist Transporthoehe.
void grip(){

	//Greifer oeffnen
	setMotorTarget(gripper, GRIPPER_MAX, GRIPPER_SPEED);
	waitUntilMotorStop(gripper);

	//Arm nach unten bewegen
	setMotorTarget(lift, GRIP_HEIGHT, LIFT_SPEED);
	waitUntilMotorStop(lift);

	//Greifer schliessen
	setMotorTarget(gripper, GRIPPER_MIN, GRIPPER_SPEED);
	sleep(500);

	//Arm nach oben bewegen
	setMotorTarget(lift, TRANSPORT_HEIGHT, LIFT_SPEED);
	waitUntilMotorStop(lift);
}

//Packet ablegen von Transporthoehe. Endposition ist Scanhoehe.
int drop(int positionDrop){

	//Arm zum Abwerfen bewegen
	setMotorTarget(turn, positionDrop, TURN_SPEED_FAST);
	waitUntilMotorStop(turn);

	//Arm senken
	setMotorTarget(lift, DROP_HEIGHT, LIFT_SPEED);
	waitUntilMotorStop(lift);

	//Greifer oeffnen
	setMotorTarget(gripper, GRIPPER_MAX, GRIPPER_SPEED);
	waitUntilMotorStop(gripper);

	//Arm heben
	setMotorTarget(lift, SCAN_HEIGHT, LIFT_SPEED);
	waitUntilMotorStop(lift);

	//Greifer schliessen
	setMotorTarget(gripper, GRIPPER_MIN, GRIPPER_SPEED);
	waitUntilMotorStop(gripper);

	return 1;

}

//Wuerfel suchen durch hin- und herschwenken des Roboterarms
int searchCube(int direction){

	if(direction == CLOCKWISE){

		while((checkColour() == 1) && (getMotorEncoder(turn) <= TURN_RADIUS_MAX)){
			setMotorSpeed(turn, TURN_SPEED_FAST);
		}
		setMotorSpeed(turn, STOP);
		return 1;
	} else {

		while((checkColour() == 1) && (getMotorEncoder(turn) >= TURN_RADIUS_MIN)){
			setMotorSpeed(turn, -TURN_SPEED_FAST);
		}
		setMotorSpeed(turn, STOP);
		return 0;
	}
}

//Ueberpruefen, ob Farbe schon abgearbeitet wurde.
int checkColour(){

	currentColour = SensorValue[Colour];
	switch(currentColour){

		case BLUE:

			if(blueDropped != 1){
				return 0;
			}
			break;

		case GREEN:

			if(greenDropped != 1){
				return 0;
			}
			break;

		case RED:

			if(redDropped != 1){
				return 0;
			}
			break;
	}
	return 1;
}

//Offset fahren in Abhaengigkeit der Drehrichtung
void offset(int direction){

	if(direction == COUNTERCLOCKWISE){

		moveMotorTarget(turn, GRIPPER_OFFSET_RIGHT, TURN_SPEED_SLOW);
		waitUntilMotorStop(turn);

	} else {

		moveMotorTarget(turn, GRIPPER_OFFSET_LEFT, TURN_SPEED_SLOW);
		waitUntilMotorStop(turn);

	}
}
