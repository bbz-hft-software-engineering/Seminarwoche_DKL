#pragma config(Sensor, S4,     Colour,         sensorEV3_Color, modeEV3Color_Color)
#pragma config(Motor,  motorB,          lift,          tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorC,          gripper,       tmotorEV3_Medium, PIDControl, encoder)
#pragma config(Motor,  motorD,          turn,          tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

void initialising(int turnSpeedFast, int turnRadiusMax, int liftSpeed, int liftHeightMax);
void grip(int gripperMin, int gripperMax, int gripperSpeed, int gripHeight, int transportHeight, int liftSpeed);
void drop(int dropPosition, int turnSpeedFast, int dropHeight, int liftSpeed, int gripperMin, int gripperMax, int gripperSpeed, int scanHeight);

task main(){

	int turnSpeedFast = 10;
	int turnSpeedSlow = 3;
	int liftSpeed = 60;
	int gripperSpeed = 50;
	int turnRadiusMin = 0;
	int turnRadiusMax = 900;
	int liftHeightMax = 0;
	int gripperMax = 63;
	int gripperMin = 0;
	int gripperOffsetRight = 80;
	int gripperOffsetLeft = 50;
	int scanHeight = 900;
	int gripHeight = 1800;
	int dropHeight = 1800;
	int transportHeight = 0;
	int dropPosition = 0;
	short currentColour = 0;

	//Motorbremse aktivieren
	setMotorBrakeMode(turn, motorBrake);
	setMotorBrakeMode(lift, motorBrake);
	setMotorBrakeMode(gripper, motorBrake);

	initialising(turnSpeedFast, turnRadiusMax, liftSpeed, liftHeightMax);

	waitForButtonPress();
	sleep(2000);

	//Arm an linkes Ende bewegen
	setMotorTarget(turn, turnRadiusMin, turnSpeedFast);
	waitUntilMotorStop(turn);

	//Arm auf Scanhöhe heben.
	setMotorTarget(lift, scanHeight, liftSpeed);
  waitUntilMotorStop(lift);

	while(1){

		currentColour = 1;

  	//Solange Farbe == schwarz oder weiss ist und der maximale Schwenkradius nicht erreicht wurde: Arm im Uhrzeigersinn drehen
		while((SensorValue[Colour] == (1 || 6)) && (getMotorEncoder(turn) <= turnRadiusMax)){
			setMotorSpeed(turn, turnSpeedFast);
			displayCenteredBigTextLine(4, "%d", currentColour);
		}

		currentColour = SensorValue[Colour];
		setMotorSpeed(turn, 0);

		switch(currentColour){

			case 2:

				dropPosition = 900;

				//Offset fahren, damit Greifer über Packet steht
				moveMotorTarget(turn, gripperOffsetRight, turnSpeedSlow);
				waitUntilMotorStop(turn);

				grip(gripperMin, gripperMax, gripperSpeed, gripHeight, transportHeight, liftSpeed);
				drop(dropPosition, turnSpeedFast, dropHeight, liftSpeed, gripperMin, gripperMax, gripperSpeed, scanHeight);
				break;

			case 5:

				dropPosition = 0;

				//Offset fahren, damit Greifer über Packet steht
				moveMotorTarget(turn, gripperOffsetRight, turnSpeedSlow);
				waitUntilMotorStop(turn);

				grip(gripperMin, gripperMax, gripperSpeed, gripHeight, transportHeight, liftSpeed);
				drop(dropPosition, turnSpeedFast, dropHeight, liftSpeed, gripperMin, gripperMax, gripperSpeed, scanHeight);
				break;

		}

		sleep(1000);

		//Solange Farbe != rot und der maximale Schwenkradius nicht erreicht ist: Arm im Uhrzeigersinn drehen
		while((SensorValue[Colour] == (1 || 6)) && (getMotorEncoder(turn) >= turnRadiusMin)){
			setMotorSpeed(turn, -turnSpeedFast);
			displayCenteredBigTextLine(4, "%d", currentColour);
		}

		currentColour = SensorValue[Colour];
		setMotorSpeed(turn, 0);

		switch(currentColour){

			case 2:

				dropPosition = 900;

				//Offset fahren, damit Greifer über Packet steht
				moveMotorTarget(turn, gripperOffsetLeft, turnSpeedSlow);
				waitUntilMotorStop(turn);

				grip(gripperMin, gripperMax, gripperSpeed, gripHeight, transportHeight, liftSpeed);
				drop(dropPosition, turnSpeedFast, dropHeight, liftSpeed, gripperMin, gripperMax, gripperSpeed, scanHeight);
				break;

			case 5:

				dropPosition = 0;

				//Offset fahren, damit Greifer über Packet steht
				moveMotorTarget(turn, gripperOffsetLeft, turnSpeedSlow);
				waitUntilMotorStop(turn);

				grip(gripperMin, gripperMax, gripperSpeed, gripHeight, transportHeight, liftSpeed);
				drop(dropPosition, turnSpeedFast, dropHeight, liftSpeed, gripperMin, gripperMax, gripperSpeed, scanHeight);
				break;

		}

		sleep(1000);

  }
}

//Motor drehen kalibrieren. Max Links = 0, Max Rechts = 600
void initialising(int turnSpeedFast, int turnRadiusMax, int liftSpeed, int liftHeightMax){

	setMotorTarget(turn, -(turnRadiusMax/2), turnSpeedFast);
  waitUntilMotorStop(turn);
  resetMotorEncoder(turn);
  sleep(500);
  setMotorTarget(turn, turnRadiusMax, turnSpeedFast);
  waitUntilMotorStop(turn);
  sleep(500);
  setMotorTarget(turn, turnRadiusMax/2, turnSpeedFast);
  waitUntilMotorStop(turn);
}

//Greifvorgang von Scanhöhe durchführen. Endposition ist Transporthöhe.
void grip(int gripperMin, int gripperMax, int gripperSpeed, int gripHeight, int transportHeight, int liftSpeed){

			//Greifer öffnen
			setMotorTarget(gripper, gripperMax, gripperSpeed);
			waitUntilMotorStop(gripper);

			//Arm nach unten bewegen
			setMotorTarget(lift, gripHeight, liftSpeed);
			waitUntilMotorStop(lift);

			//Greifer schliessen
			setMotorTarget(gripper, gripperMin, gripperSpeed);
			sleep(500);

			//Arm nach oben bewegen
			setMotorTarget(lift, transportHeight, liftSpeed);
			waitUntilMotorStop(lift);
}

//Packet ablegen von Transporthöhe. Endposition Scanhöhe.
void drop(int dropPosition, int turnSpeedFast, int dropHeight, int liftSpeed, int gripperMin, int gripperMax, int gripperSpeed, int scanHeight){

	//Arm zum Abwerfen bewegen
	setMotorTarget(turn, dropPosition, turnSpeedFast);
	waitUntilMotorStop(turn);

	//Arm senken
	setMotorTarget(lift, dropHeight, liftSpeed);
	waitUntilMotorStop(lift);

	//Greifer öffnen
	setMotorTarget(gripper, gripperMax, gripperSpeed);
	waitUntilMotorStop(gripper);

	//Arm heben
	setMotorTarget(lift, scanHeight, liftSpeed);
	waitUntilMotorStop(lift);

	//Greifer schliessen
	setMotorTarget(gripper, gripperMin, gripperSpeed);
	waitUntilMotorStop(gripper);

}
